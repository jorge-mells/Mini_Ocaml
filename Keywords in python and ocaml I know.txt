Python
variable binding can be done without any keywords. '_' can be used to name a variable to not be used.
command line keywords include: 'cd .../ cd/ cd foldername', 'code filename', 'python/python filename arguments(optional)', 'pytest filename/foldername'(with folders, folder must have __init__.py), 'rm filename', 'mkdir foldername'
tabulation defines scope.
The various python given types include strings(immutable), lists(can be unpacked with *list), integers(immutable), dictionaries(can be unpacked with **dict), floats, tuples(can be unpacked e.g. a, b = (1,2)), None(for functions that don't return anything eg print). They can't be used together. '+' can be used with them depending on constraints, their individual parts can be accessed with '[](numbers represent indexes and words for dictionaries)', they can be sliced even with negative numbers('[:]'), their lengths can be found using index. Check python docs for their methods because they are technically classes. Important string methods include strip, capitalize, islower, split, endswith, etc. Important list methods include index, append. types can be converted. eg: int('2') gives 2.
functions are defined by 'def' keyword with all parameters put in a bracked immediately after function name. Optional parameters must be given defaul value with '='. All code for the function is tabulated. Function values can be returned with 'return' keyword. All functions can be used in the 'main' variable, which can then be called at the bottom with 'if name = main: main()'(this is used so that imported packages are not run when the programs they are used in are called).
control flow tools include 'while', 'for .. in ..', 'if, else, elif', if ... (not) in..', <b>'try'... 'except'... 'else'</b>, <b>'raise'</b>, 'match', 'case'. Complements for control flow tools are 'pass', 'continue', 'break'. Some exceptions include: SyntaxError, ValueError, IndexError, AssertionError, DivionByZeroError(not sure), NameError, 
libraries, or modules are pieces of program others have made that you can use in your program, with the 'import/ import from' keyword. Packages are a collection of modules, usually third party. API's as their name suggest are interfaces(ways to access the functionalities of their programs) to the programs of others. Popular modules include sys(sys.argv, sys.exit), random, statistics, cowsay.
the pytest module is used to test programs. 'assert' can be used to say a statement should be true, and if it is not an error(AssertionError) is raised. 'with pytest.raises(error): functionname' can be used to check programs that raise errors. classes can be tested by being imported.
'open(filename, 'r/w/a')','file.write(str)/close()', 'file.readlines()'(or pythonic for loop to access lines), 'with open(arg1, arg2) as file: <>' , check 'csv'/'PIL' module for info on it.
the module re includes functions like search(regex, str, flags), match, fullmatch, sub(like replace), split, findall(check re for more and flags like IGNORECASE. Syntax: r""(raw string), \(excape), ^(begin), $(end), .(any char), *(zero or more), +(one or more), ?(zero or one), ()(capture group can be accesed with var.groups(<index from 1>)), (?:)(non capture group), [](contains), [^](not contain), {n,m}(contains from n to m characters(or if no m more than/ equal n, or if no n, less than/equal m)), {n}(contains exactly n chars), |(or) a-z, A-Z, 1-9, \d([0-9]), \w([A-Za-z0-9_]), \b(seperators between words such as whitespace, commas, etc), \s(strictly whitespace ([ \t\r\n\v\f])), \(<letter capitalized>) means negative e.g. \D means [^0-9]. Check re for advanced regexes.
classes are essentially definitions for new customized datatypes in python. They can be defined with <class 'Class'>. Every class can be instantiated as an object when called with its parameters(e.g. hello = Hello(parameters)). __str__ can be used to determine what the object returns anytime it is asked to return something. __add__ is used to determine what happens when two objects of that class are added(other operator overloaders exist check docs). __init__ used to define variables each object must have on its own. Each object method must have self as one of its parameters, and each object variable must have 'self.variable'. Class variables can stand alone and class methods can be called with the decorator @classmethod on top of them. Properties are object variables which are special(usually you're not allowed to change them), and a property(or getter) is a function with @property on top of them. @functionname.setter is on top of property setters. Any time a property is defined, it must have a setter. The getter determines what happens anytime the object variable is called and the setter determines what happens anytime someone tries to change the object variable. classes may inherit from superclasses(class Inherit(Father)). super() may be used to determine what is inherited(check docs for more)
More: sets are like the mathematical object(check docs for more), global variables cannot be mutated inside local scopes. to do that, use global keyword before var. Typing and type hints can be controlled using mypy, and type hints(check docs for more), docstrings can be used for documentation("""string"""). Sphinx can be used to parse these to documentation. Check arparse documentation for more info on parsing complex arguments. Check docs for args and kwargs, which can be used as function params (*args, **kwargs). use map like in ocaml. lambdas are unnamed functions(check docs for more/eg(lambda param: <>)), filter like in ocaml. check docs for list comprehensions/pythonic. you can use the yield keyword for generators(check docs for more). 
