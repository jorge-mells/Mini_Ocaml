<!DOCTYPE html>
<html>
  <head>Notes</head>
  <body>
    <h2>Python</h2>
    <ol>
      <li>variable binding can be done without any keywords. '_' can be used to name a variable to not be used.</li>
      <li>command line keywords include: 'cd .../ cd/ cd foldername', 'code filename', 'python/python filename arguments(optional)',   'pytest filename/foldername'(with folders, folder must have __init__.py), 'rm filename', 'mkdir foldername' tabulation defines scope.</li>
      <li>The various python given types include strings(immutable), lists(can be unpacked with *list), integers(immutable), dictionaries(can be unpacked with **dict), floats, tuples(can be unpacked e.g. a, b = (1,2)), None(for functions that don't return anything eg print). They can't be used together. '+' can be used with them depending on constraints, their individual parts can be accessed with '[](numbers represent indexes and words for dictionaries)', they can be sliced even with negative numbers('[:]'), their lengths can be found using index. Check python docs for their methods because they are technically classes. Important string methods include strip, capitalize, islower, split, endswith, etc. Important list methods include index, append. types can be converted. eg: int('2') gives 2.</li>
      <li>functions are defined by 'def' keyword with all parameters put in a bracked immediately after function name. Optional parameters must be given defaul value with '='. All code for the function is tabulated. Function values can be returned with 'return' keyword. All functions can be used in the 'main' variable, which can then be called at the bottom with 'if name = main: main()'(this is used so that imported packages are not run when the programs they are used in are called).</li>
      <li>control flow tools include 'while', 'for .. in ..', 'if, else, elif', if ... (not) in..', <b>'try'... 'except'... 'else'</b>, <b>'raise'</b>, 'match', 'case'. Complements for control flow tools are 'pass', 'continue', 'break'. Some exceptions include: SyntaxError, ValueError, IndexError, AssertionError, DivionByZeroError(not sure), NameError</li>
      <li>libraries, or modules are pieces of program others have made that you can use in your program, with the 'import/ import from' keyword. Packages are a collection of modules, usually third party. API's as their name suggest are interfaces(ways to access the functionalities of their programs) to the programs of others. Popular modules include sys(sys.argv, sys.exit), random, statistics, cowsay.</li>
      <li>the pytest module is used to test programs. 'assert' can be used to say a statement should be true, and if it is not an error(AssertionError) is raised. 'with pytest.raises(error): functionname' can be used to check programs that raise errors. classes can be tested by being imported.</li>
      <li>'open(filename, 'r/w/a')','file.write(str)/close()', 'file.readlines()'(or pythonic for loop to access lines), 'with open(arg1, arg2) as file: <>' , check 'csv'/'PIL' module for info on it.</li>
      <li>the module re includes functions like search(regex, str, flags), match, fullmatch, sub(like replace), split, findall(check re for more and flags like IGNORECASE. Syntax: r""(raw string), \(excape), ^(begin), $(end), .(any char), *(zero or more), +(one or more), ?(zero or one), ()(capture group can be accesed with var.groups(<index from 1>)), (?:)(non capture group), [](contains), [^](not contain), {n,m}(contains from n to m characters(or if no m more than/ equal n, or if no n, less than/equal m)), {n}(contains exactly n chars), |(or) a-z, A-Z, 1-9, \d([0-9]), \w([A-Za-z0-9_]), \b(seperators between words such as whitespace, commas, etc), \s(strictly whitespace ([ \t\r\n\v\f])), \(<letter capitalized>) means negative e.g. \D means [^0-9]. Check re for advanced regexes.</li>
      <li>classes are essentially definitions for new customized datatypes in python. They can be defined with <class 'Class'>. Every class can be instantiated as an object when called with its parameters(e.g. hello = Hello(parameters)). __str__ can be used to determine what the object returns anytime it is asked to return something. __add__ is used to determine what happens when two objects of that class are added(other operator overloaders exist check docs). __init__ used to define variables each object must have on its own. Each object method must have self as one of its parameters, and each object variable must have 'self.variable'. Class variables can stand alone and class methods can be called with the decorator @classmethod on top of them. Properties are object variables which are special(usually you're not allowed to change them), and a property(or getter) is a function with @property on top of them. @functionname.setter is on top of property setters. Any time a property is defined, it must have a setter. The getter determines what happens anytime the object variable is called and the setter determines what happens anytime someone tries to change the object variable. classes may inherit from superclasses(class Inherit(Father)). super() may be used to determine what is inherited(check docs for more)</li>
      <li>More: sets are like the mathematical object(check docs for more), global variables cannot be mutated inside local scopes. to do that, use global keyword before var. Typing and type hints can be controlled using mypy, and type hints(check docs for more), docstrings can be used for documentation("""string"""). Sphinx can be used to parse these to documentation. Check arparse documentation for more info on parsing complex arguments. Check docs for args and kwargs, which can be used as function params (*args, **kwargs). use map like in ocaml. lambdas are unnamed functions(check docs for more/eg(lambda param: <>)), filter like in ocaml. check docs for list comprehensions/pythonic. you can use the yield keyword for generators(check docs for more).</li>
    </ol>
    <h2>Assembly</h2>
    <ol>
      <li>At the lowest level, computers read programs as binary files. Higher level programs are translated into several instructions. Directly above binary is assembly language. Which sometimes contains decimals, hexadecimals and binary</li>
      <li>An assembly language is translated into a single instruction to the computer. To convert from hex to binary, use the '8421' rule. Instructions are read as a series of bytes. A single bit is a component of a byte which has 8 bits.</li>
      <li>A program in assembly language is a set of instructions and data. Instructions are represented in IBMs language as an operation and a series of operands. An operand may be a direct access to data, indirect access or memory. Operands may be source or destination, the first is usually destination.</li>
      <li>There are several datatypes in assembly to prevent problems with mixing of datatypes: characters, packed decimals, etc. Characters may be represented using the EBCDIC convention e.g. for '12', each number would be given its hex representation and so it could be xE244. Packed decimals represent numbers e.g. +1248 = x01248C (D is for negative)</li>
      <li>The fetch execute cycle is the CPU's most basic operation. At the lowest level in computers, this cycle is what programs are broken down into, a series of instructions. Firstly, the CPU fetches instructions from memory, then the CU decodes this instruction deciding which component performs the next task. Then finally, the instruction is executed by the ALU, GPU, or the FPU. Then the cycle is repeated</li>
      <li>Data and programs in the computer may be stored in registers, caches, main memory, flash disks, secondary storage(internet). These devices are arranged from most expensive, smallest, fastest data access by CPU to cheapest, largest, slowest data access(depending on the number of cycles required to access data from them).</li>
      <li>IBMs z/architecture can move 64 bits around at a time, is "big endian"(a bit complex), and uses "rich CSIC"(instructions are executed in smaller steps(something like this)). In this there are 16 GPRs, 16 ARs, 16 FPRs, 16 CRs, and the PSW which stores the address of the next instruction., and flags to show the result of cycles.</li>
      <li>In this architecture, a word is 4B, and half word is 2B. Memory is organized such that 1B is stored and is assigned an address. Bytes are then combined into words and the address of the address is the smallest address of a byte. The same can be said for halfwords and double words. Also programs and data share the same memory.</li>
      <li>Data types include: fixed point data, floating point data, packed decimal data, character data(usually in EBCDIC), address-valued data(like pointers), logical data(usually interpreted as binary), DC(define datatype and initialize) and DS(define datatype) instructions are used when program is converted from assembler to machine. In memory, character data is space padded to the right, while numeric is usually 0 padded to the left</li>
      <li>DC and DS are used to kinda initialize registers to store datatypes. In assembler language, there are no </li>
    </ol>
  </body>
</html>
